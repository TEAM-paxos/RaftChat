//
// This code was generated by a tool.
//
//
//   bebopc version:
//       3.0.4
//
//
//   bebopc source:
//       https://github.com/betwixt-labs/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[derive(Clone, Debug, PartialEq)]
pub struct Message<'raw> {
    pub from: &'raw str,
    pub to: &'raw str,
    pub msg: &'raw str,
}

impl<'raw> ::bebop::SubRecord<'raw> for Message<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE
        + <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.from.serialized_size() + self.to.serialized_size() + self.msg.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.from._serialize_chained(dest)? +
            zelf.to._serialize_chained(dest)? +
            zelf.msg._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                from: v0,
                to: v1,
                msg: v2,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Message<'raw> {}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Message {
        pub from: String,
        pub to: String,
        pub msg: String,
    }

    impl<'raw> ::core::convert::From<super::Message<'raw>> for Message {
        fn from(value: super::Message) -> Self {
            Self {
                from: value.from.into(),
                to: value.to.into(),
                msg: value.msg.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Message {
        const MIN_SERIALIZED_SIZE: usize = <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE
            + <String>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.from.serialized_size() + self.to.serialized_size() + self.msg.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.from._serialize_chained(dest)? +
                zelf.to._serialize_chained(dest)? +
                zelf.msg._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    from: v0,
                    to: v1,
                    msg: v2,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Message {}
}
